<!DOCTYPE html>
<html>

<head>
	<meta charset='utf-8'>
	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
	<link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
	<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

	<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

	<title>Frontend questions by Gautampsingh</title>
</head>

<body>
	<header>
		<div class="inner">
			<h1>Frontend questions</h1>
			<h2></h2>
			<a href="https://github.com/Gautampsingh/frontend_questions" class="button"><small>View project on</small>
				GitHub</a>
		</div>
	</header>

	<div id="content-wrapper">
		<div class="inner clearfix">
			<section id="main-content">

				<h3>
					<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true">
						<span aria-hidden="true" class="octicon octicon-link"></span>
					</a>
					Welcome to Frontend Questions Pages.</h3>

				<p>This page is the easiest way for any front-end developers to crack the interview.
					I believe these are the topics which any frontend developers should know before attending the
					interviews. If you do cover these topics believe me your chances of cracking the interview will rise
					to 70-80%.
				<div>Also you can check or follow
					<a href="https://medium.com/@goutampsingh/journey-of-a-front-end-developer-742dfa6214d8"
						target="blank" aria-label="Journey of a Front-end developer from Scratch"
						title='Journey of a Front-end developer from Scratch'>
						My Blog
					</a>
					if you are <code><b>New to Frontend development</b></code>
					also I am updating the contents
					with lots more other topics and questions. This is the initial release which covered the common
					interview topics from
					JavaScript, Angular and RxJS.
				</div>
				</p>


				<h3>Web application performance: web pages response time can be improved by 25 to 50 percent by this
					rules</h3>
				<pre>
1) Minimize HTTP requests.
2) Use a content delivery network - Users request redirected to their nearest servers.
3) Add an Expires or a Cache-Control header.
5) Put stylesheets at the top.
6) Put scripts at the bottom.
7) Make JavaScript and CSS external
8) Avoid CSS expressions.
9) Optimize the size of images on your website:
	The best way to reduce the image size without compromising its quality is to compress images using such tools as ImageOptim, JPEGmini, or Kraken.
	Another way to reduce the image size is to use the HTML responsive images and attributes that adjust image size based on user display properties.
10) Reduce the number of plugins
11) Minimize the number of javascript and css files
12) Use website caching
13) Reduce use of web fonts like WOFF2 for faster page rendering
14) Reduce redirects - Redirection create additional http requests which negative impact performance
15) Use cookie-free domain components
16) Gzip components.
</pre>

				<h3>Programmming paradigms</h3>
				<pre>
<b>Imperative: Object Oriented programming</b>

let arr = [1,2,3,4,5];
arr2 = [];
for(let i = 0;i&lt;arr.length;i++){
	arr[i] = arr[i]*2;
}
console.log(arr2);

<b>Declarative: functional programming</b>

let arr = [1,2,3,4,5];
arr2 = arr.map(function(v, i){
	return v*2;
});
console.log(arr2);
</pre>

				<h3>Design patterns javascript</h3>
				<pre>
1) <b>Module design pattern</b>:  Function variable with self invoking having all the methods encapsulated inside it
	create functions as module where we can 
2) <b>Prototype</b>
	TeslaModelS.prototype.go = function() {
		// Rotate wheels
	}
3) <b>Singleton</b>: A Singleton only allows for a single instantiation, but many instances of the same object. 
	The Singleton restricts clients from creating multiple objects, after the first object created, it will return instances of itself.
	var officePrinter = printer.getInstance();
4) <b>Observer</b>: There are many times when one part of the application changes, other parts needs to be updated.
var Subject = function() {
	this.observers = [];
	return {
		subscribeObserver: function(observer) {
			this.observers.push(observer);
		}
	};
};

var Observer = function() {
	return {
	notify: function(index) {
		console.log("Observer " + index + " is notified!");
	}
	}
}

var subject = new Subject();
var observer1 = new Observer();
subject.subscribeObserver(observer1);
</pre>

				<h3>Different ways to create an object:</h3>
				<pre>
1) <b>Object Literals</b>
var car = {
	model: 'bmw',
	color: 'red',
	price: 2000
}
	
2) <b>New operator or constructor</b>
function Car(model, color) {
	this.model = model;
	this.color = color;
}
var c1 = new Car('BMW', 'red');
	
3) <b>Object.create method</b>
var Car = {
	model: 'BMW',
	color: 'red'
}
var ElectricCar = Object.create(Car);
console.log(ElectricCar.model); // BMW
4) <b>Class</b>
class Car {
	constructor(maker, price) {
		this.maker = maker;
		this.price = price;
	}
	getInfo() {
		console.log(this.maker + " costs : " + this.price);
	}
}
</pre>

				<h3>Observables and Promises</h3>
				<pre>
An Observable is like a Stream (in many languages) and allows to pass zero or more events where the callback is called for each event. 
Often Observable is preferred over Promise because it provides the features of Promise and more. 
With Observable it doesn't matter if you want to handle 0, 1, or multiple events.
Observable also has the advantage over Promise to be cancelable.
If the result of an HTTP request to a server or some other expensive async operation isn't needed anymore, 
the Subscription of an Observable allows to cancel the subscription, 
while a Promise will eventually call the success or failed callback even when you don't need the notification or the result it provides anymore.
Promise is always asynchronous, while an Observable can be either synchronous or asynchronous.
	
Promise
A Promise handles a single event when an async operation completes or fails. Promise is always asynchronous and non-cancelable.
Once the operation started whether it gives resolve/success or reject/failure
</pre>

				<h3>ES6 includes the following new features:</h3>
				<pre>
arrows function
classes
enhanced object literals
template strings
destructuring
default + rest + spread
let + const
iterators + for..of
promises
generators
unicode
modules
module loaders
map + set + weakmap + weakset
proxies
symbols
subclassable built-ins
math + number + string + array + object APIs
binary and octal literals
reflect api
tail calls
</pre>

				<h3>Rest and Spread operators</h3>
				<pre>
<b>Rest operator</b>: The ...rest must always be last.
function showName(firstName, lastName, ...titles) {
	alert( firstName + ' ' + lastName ); // Julius Caesar
	// the rest go into titles array
	// i.e. titles = ["Consul", "Imperator"]
	alert( titles[0] ); // Consul
	alert( titles[1] ); // Imperator
}
showName("Julius", "Caesar", "Consul", "Imperator");

<b>Spread operator</b> 
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [...arr, ...arr2];
console.log(merged); // 3,5,1,8,9,15
</pre>

				<h2>RXJS</h2>
				<div class="bgColor">
					<h3>Subject</h3>
					<div>
						A special type of Observable which shares a single execution path among observers

						<pre>
import { Subject } from 'rxjs';

const sub = new Subject();

sub.next(1);
sub.subscribe(x => {
console.log('Subscriber A', x);
});
sub.next(2); // OUTPUT => Subscriber A 2
sub.subscribe(x => {
console.log('Subscriber B', x);
});
sub.next(3); // OUTPUT => Subscriber A 3, Subscriber B 3 (logged from both subscribers)
</pre>
					</div>

					<h3>BehaviourSubject</h3>
					<div>
						The BehaviorSubject has the characteristic that it stores the “current” value. This means that
						you can
						always directly get the last emitted value from the BehaviorSubject.
						<pre>
import * as Rx from "rxjs";

const subject = new Rx.BehaviorSubject(Math.random());

// subscriber 1
subject.subscribe((data) => {
console.log('Subscriber A:', data);
});

// output
// Subscriber A: 0.24957144215097515
</pre>
					</div>

					<h3>ReplaySubject</h3>
					<div>
						The ReplaySubject is comparable to the BehaviorSubject in the way that it can send “old” values
						to new
						subscribers.
						It however has the extra characteristic that it can record a part of the observable execution
						and therefore
						store multiple old values and “replay” them to new subscribers.
						When creating the ReplaySubject you can specify how much values you want to store and for how
						long you want
						to store them.
					</div>
					<pre>
import * as Rx from "rxjs";

const subject = new Rx.ReplaySubject(2);

// subscriber 1
subject.subscribe((data) => {
console.log('Subscriber A:', data);
});

subject.next(Math.random())
subject.next(Math.random())
subject.next(Math.random())

// subscriber 2
subject.subscribe((data) => {
console.log('Subscriber B:', data);
});

subject.next(Math.random());

// Subscriber A: 0.3541746356538569
// Subscriber A: 0.12137498878080955
// Subscriber A: 0.531935186034298
// Subscriber B: 0.12137498878080955
// Subscriber B: 0.531935186034298
// Subscriber A: 0.6664809293975393
// Subscriber B: 0.6664809293975393
</pre>

					<h3>AsyncSubject</h3>
					<div>
						While the BehaviorSubject and ReplaySubject both store values, the AsyncSubject works a bit
						different.
						The AsyncSubject is aSubject variant where only the last value of the Observable execution is
						sent to its
						subscribers, and only when the execution completes.
					</div>
					<pre>
import * as Rx from "rxjs";

const subject = new Rx.AsyncSubject();

// subscriber 1
subject.subscribe((data) => {
console.log('Subscriber A:', data);
});

subject.next(Math.random())
subject.next(Math.random())
subject.next(Math.random())

// subscriber 2
subject.subscribe((data) => {
console.log('Subscriber B:', data);
});

subject.next(Math.random());
subject.complete();

// Subscriber A: 0.4447275989704571
// Subscriber B: 0.4447275989704571
</pre>
				</div>

				<h2>Fixing CORS Issues in Your Front-End Angular 7/8 App with Angular CLI Proxy Configuration</h2>
				<div>
					<a href="https://www.techiediaries.com/fix-cors-with-angular-cli-proxy-configuration/"
						rel="noreferrer noopener"></a>
				</div>
				<pre>
<b>Step 1 - Create a Proxy Configuration File(src/proxy.conf.json)</b>
{
    "/api/*": {
        "target": "http://localhost:3000",
        "secure": false,
        "logLevel": "debug"
    }
}
This configuration file specifies that any HTTP request which starts with the /app/ path will be sent to the proxy which will redirect it to the target hostname.
The secure option is used to enforce usage of SSL.

<b>Step 2 - Add a proxyConfig key to angular.json</b>
Next, open the angular.json file and add a proxyConfig key under the serve->options that points to the src/proxy.conf.json file as follows:
"architect": {
  "serve": {
    "builder": "@angular-devkit/build-angular:dev-server",
    "options": {
      "browserTarget": "your-application-name:build",
      "proxyConfig": "src/proxy.conf.json"
    },

<b>Step 3 - Serving your Angular App (ng serve)</b>
</pre>

				<h2>6 Ways to Unsubscribe from Observables in Angular</h2>
				<pre>
<b>Use the unsubscribe method</b>
@Component({...})
export class AppComponent implements OnInit, OnDestroy {
    subscription: Subscription 
    ngOnInit () {
        var observable = Rx.Observable.interval(1000);
        this.subscription = observable.subscribe(x => console.log(x));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe()
    }
}

<b>Use Async | Pipe</b>
@Component({
...,
template: `
<span>Interval: {{observable$ | async}}</span>
`
})
export class AppComponent implements OnInit {
	observable$
	ngOnInit () {
		this.observable$ = Rx.Observable.interval(1000);
	}
}

<b>Use RxJS take* operators</b>
take(n):
@Component({
    ...
})
export class AppComponent implements OnInit, OnDestroy {
    subscription$
    ngOnInit () {
        var observable$ = Rx.Observable.interval(1000);
        this.subscription$ = observable$.pipe(take(1)).
        subscribe(x => console.log(x))
    }
    ngOnDestroy() {
        this.subscription$.unsubscribe()
    }
}

takeUntil(notifier):
@Component({...})
export class AppComponent implements OnInit, OnDestroy {
    notifier = new Subject()
    ngOnInit () {
        var observable$ = Rx.Observable.interval(1000);
        observable$.pipe(takeUntil(this.notifier))
        .subscribe(x => console.log(x));
    }
    ngOnDestroy() {
        this.notifier.next()
        this.notifier.complete()
    }
}

takeWhile(predicate):
@Component({...})
export class AppComponent implements OnInit {
    ngOnInit () {
        var observable$ = Rx.Observable.interval(1000);
        observable$.pipe(takeWhile(value => value < 10))
        .subscribe(x => console.log(x));
    }
}

<b>Use RxJS first operator</b>
This operator is like the concatenation of take(1) and takeWhile.
If called with no value, it emits the first value emitted by the source Observable and completes.
@Component({...})
export class AppComponent implements OnInit {
    observable$
    ngOnInit () {
        this.observable = Rx.Observable.interval(1000);
        this.observable$.pipe(first())
        .subscribe(x => console.log(x));
    }
}

<b>Use Decorator to automate Unsubscription</b>
function AutoUnsub() {
    return function(constructor) {
        const orig = constructor.prototype.ngOnDestroy
        constructor.prototype.ngOnDestroy = function() {
            for(const prop in this) {
                const property = this[prop]
                if(typeof property.subscribe === "function") {
                    property.unsubscribe()
                }
            }
            orig.apply()
        }
    }
}

This AutoUnsub is a class decorator that can be applied to classes in our Angular project.
See, it saves the original ngOnDestroy hook, then creates a new one and hook it into the class it is applied on.
So, when the class is being destroyed the new hook is called.
Inside it, the functions scan through the properties of the class, if it finds an Observable property it will unsubscribe from it.
Then it calls the original ngOnDestroy hook in the class if present.

@Component({
    ...
})
@AutoUnsub
export class AppComponent implements OnInit {
    observable$
    ngOnInit () {
        this.observable$ = Rx.Observable.interval(1000);
        this.observable$.subscribe(x => console.log(x))
    }
}

</pre>

			</section>

			<aside id="sidebar">
				<a href="https://github.com/Gautampsingh/frontend_questions/zipball/master" class="button">
					<small>Download</small>
					.zip file
				</a>
				<a href="https://github.com/Gautampsingh/frontend_questions/tarball/master" class="button">
					<small>Download</small>
					.tar.gz file
				</a>

				<p class="repo-owner"><a href="https://github.com/Gautampsingh/frontend_questions"></a> is maintained by
					<a href="https://github.com/Gautampsingh">Gautampsingh</a>.</p>

				<p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect
					theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
			</aside>
		</div>
	</div>

</body>

</html>