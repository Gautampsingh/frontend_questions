<!DOCTYPE html>
<html>

<head>
	<meta charset='utf-8'>
	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
	<link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
	<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

	<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

	<title>Frontend questions by Gautampsingh</title>
	<style>
		::selection {
			background-color: #ffd723;
			color: #ff0000;
		}
	</style>
</head>

<body>
	<header>
		<div class="inner">
			<h1>Frontend questions</h1>
			<h2></h2>
			<a href="https://github.com/Gautampsingh/frontend_questions" class="button"><small>View project on</small>
				GitHub</a>
		</div>
	</header>

	<div id="content-wrapper">
		<div class="inner clearfix">
			<section id="main-content">

				<h3>
					<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true">
						<span aria-hidden="true" class="octicon octicon-link"></span>
					</a>
					Welcome to Frontend Questions Pages.</h3>

				<p>This page is the easiest way for any front-end developers to crack the interview.
					I believe these are the topics which any frontend developers should know before attending the
					interviews. If you do cover these topics believe me your chances of cracking the interview will rise
					to 70-80%.
				<div>Also you can check or follow
					<a href="https://medium.com/@goutampsingh/journey-of-a-front-end-developer-742dfa6214d8"
						target="blank" aria-label="Journey of a Front-end developer from Scratch"
						title='Journey of a Front-end developer from Scratch'>
						My Blog
					</a>
					if you are <code><b>New to Frontend development</b></code>
					also I am updating the contents
					with lots more other topics and questions. This is the initial release which covered the common
					interview topics from
					JavaScript, Angular and RxJS.
				</div>
				</p>

				<h3>Common Cross Browser Compatibility Issues to Avoid</h3>
				<pre>
1. Lack of Testing on Real Devices:
	Try testing on real devices
2. HTML/ CSS Validation
Code validating tools for HTML and CSS. Consider using W3C HTML validator and Jigsaw CSS validator.
3. Vendor-specific functions
	Safari and Chrome (-webkit)
	Internet Explorer (-ms)
	Mozilla Firefox (-moz)
	Opera (-o)
4. DOCTYPE Error
	Doctype is checked because a browser operates in two modes – Strict Mode and Quirks Mode
	In Strict Mode, the browser works with much stricter checks for code errors to make sure that the code is in accordance with W3C specifications.
	Quirks Mode provides backward compatibility to older browser versions and do not perform such meticulous code error checks.
5. Outdated Browser Detection: JavaScript failure to detect browser
	one can remove the browser detection by using Modernizer, a set of “superfast tests” that enumerate all browser features, thus facilitating a seamless experience.
6. Missing CSS Resets: Override default browser layouts
	Resolving this issue simply requires the websites rendered to be reset to the same basics. Developers can use CSS reset style sheets for this purpose.
	Commonly used reset style sheets include Eric Meyers CSS Reset, HTML5Reset, and the Github based Normalize.css.
7. Layout Compatibility
	When working with modern layouts, it is better to use tools such as CSS grids and Flexbox.
</pre>

				<h3>Web application performance: web pages response time can be improved by 25 to 50 percent by this
					rules</h3>
				<pre>
1) Minimize HTTP requests.
2) Use a content delivery network - Users request redirected to their nearest servers.
3) Add an Expires or a Cache-Control header.
5) Put stylesheets at the top.
6) Put scripts at the bottom.
7) Make JavaScript and CSS external
8) Avoid CSS expressions.
9) Optimize the size of images on your website:
	The best way to reduce the image size without compromising its quality is to compress images using such tools as ImageOptim, JPEGmini, or Kraken.
	Another way to reduce the image size is to use the HTML responsive images and attributes that adjust image size based on user display properties.
10) Reduce the number of plugins
11) Minimize the number of javascript and css files
12) Use website caching
13) Reduce use of web fonts like WOFF2 for faster page rendering
14) Reduce redirects - Redirection create additional http requests which negative impact performance
15) Use cookie-free domain components
16) Gzip components.
</pre>

				<h3>Difference between HTML4 and HTML5</h3>
				<pre>
<b>HTML4</b>
Doctype declaration is too longer
Audio, video not part of HTML4
Vector graphics is possible with the help of technologies such as VML, Silverlight, Flash etc
Impossible to get true geolocation of user browsing any website especially comes to mobile devices
Use cookies
Not possible to draw shapes like circle, rectangle and triangle
Doesnot allow JS to run in the browser. JS runs in the same thread as browser interface.
Works with all the old browsers
It's not mobile friendly
No standarized process to handle strucurally incorrect HTML codes
Offline storage support is not good

<b>HTML5</b>
Doctype is simple
Audio and videos are integral part of HTML5
Vector graphics is integral part of HTML5
JS Geolocation API helps identify location of user browsing website(provided user allows it)
It provides localstorage inplace of cookies
You can draw rectangle, circle and triangle
Allow JS to run in the background. This is possible due to JS Web worker API in HTML5
Supported by all new major browsers
It's Mobile friendly
It supports persistent error handling via improvised error handling process.
New Semantic elements added(Header, section, aside, article, footer)
Offline storage support is good
HTML5 API- Geolocation, Drag/Drop, Web storage, Web workers, Server-Sent Events(SSE)

<b>HTML Layout Elements</b>
HTML has several semantic elements that define the different parts of a web page:
&lt;header&gt; - Defines a header for a document or a section
&lt;nav&gt; - Defines a set of navigation links
&lt;section&gt; - Defines a section in a document
&lt;article&gt; - Defines an independent, self-contained content
&lt;aside&gt; - Defines content aside from the content (like a sidebar)
&lt;footer&gt; - Defines a footer for a document or a section
&lt;details&gt; - Defines additional details that the user can open and close on demand
&lt;summary&gt; - Defines a heading for the &lt;details&gt; element
</pre>

				<h3>CSS</h3>
				<pre>
<b>CSS Box model</b>
The CSS box defines the design and the layout of elements of CSS. The several elements are:
Margin: transparent area outside border
Border: the padding and content option with a border around it is shown.
Padding: Space is around content. Padding is transparent.
Content: box where text and images appear.
e.g.:
div{
	width: 300px;
	border: 25px solid  yellow;
	padding: 25px;
	margin:  25px;
}

<b>Various Media types used</b>
Aural – for sound synthesizers and speech
Print – gives a preview of the content when printed
Projection- projects the CSS on projectors.
Handheld- uses handheld devices.
Screen- computers and laptop screens.

<b>What is Pseudo elements and Pseudo classes?</b>
Pseudo-elements are keyword added to the selector that allows one o style a specific part of the selected element.
1) To style the first letter, line or element
2) To insert a content
<i>Syntax</i>
Selector: :pseudo-element {
	property1 :value;
	property2 :value;	
}
Example: ::after, ::before

A pseudo-class is used to define a special state of an element.You can use them for
1) Style an element when someone mouses over it
2) Style visited and unvisited links differently
3) Style an element when it gets focus

<i>Syntax</i>
selector:pseudo-class {
	property: value;
}
Example: a:hover, a:visited

<b>HTML Layout Techniques</b>
There are four different techniques to create multicolumn layouts. Each technique has its pros and cons:
1) CSS framework: Bootstrap, Foundation, Bulma, etc..
2) CSS float property: Float: left/right/none/inherit and Clear
3) CSS flexbox: To start using the Flexbox model, you need to first define a flex container.
The flex container properties are:
flex-direction
flex-wrap
flex-flow
justify-content
align-items
align-content

4) CSS grid: Many web pages are based on a grid-view, which means that the page is divided into columns.
A responsive grid-view often has 12 columns, and has a total width of 100%, and will shrink and expand as you resize the browser window.
.col-1 {width: 8.33%;}
.col-2 {width: 16.66%;}
.col-3 {width: 25%;}
.col-4 {width: 33.33%;}
.col-5 {width: 41.66%;}
.col-6 {width: 50%;}
.col-7 {width: 58.33%;}
.col-8 {width: 66.66%;}
.col-9 {width: 75%;}
.col-10 {width: 83.33%;}
.col-11 {width: 91.66%;}
.col-12 {width: 100%;}

<b>Media Queries</b>
Media query is a CSS technique introduced in CSS3.
It uses the @media rule to include a block of CSS properties only if a certain condition is true.
If the browser window is 600px or smaller, the background color will be lightblue:
@media only screen and (max-width: 768px) {
	/* For mobile phones: */
	[class*="col-"] {
	  width: 100%;
	}
  }

<b>Always Design for Mobile First</b>
Mobile First means designing for mobile before designing for desktop or any other device (This will make the page display faster on smaller devices).
This means that we must make some changes in our CSS.
Instead of changing styles when the width gets smaller than 768px, we should change the design when the width gets larger than 768px. 
This will make our design Mobile First.
/* For mobile phones: */
[class*="col-"] {
  width: 100%;
}

@media only screen and (min-width: 768px) {
  /* For desktop: */
  .col-1 {width: 8.33%;}
  .col-2 {width: 16.66%;}
  .col-3 {width: 25%;}
  .col-4 {width: 33.33%;}
  .col-5 {width: 41.66%;}
  .col-6 {width: 50%;}
  .col-7 {width: 58.33%;}
  .col-8 {width: 66.66%;}
  .col-9 {width: 75%;}
  .col-10 {width: 83.33%;}
  .col-11 {width: 91.66%;}
  .col-12 {width: 100%;}
}

<b>Have you used Flexbox & CSS Grid before? What are the differences between them?</b>
Flexbox is a very useful layout tool, especially for smaller areas within the site. 
Its main features are to align items in horizontal or vertical axes, space them out automatically, 
invert the order in which they’re displayed, along with a few other layout options.

CSS Grid is more of a layout tool for the entire page. While Flexbox excels in laying out items along a single axis, 
Grid is better for layouts with both horizontal and vertical axes, i.e. grids!

<b>What is CSS preprocessor?</b>
CSS preprocessors are scripting languages that extend the default capabilities of CSS. 
They enable us to use logic in our CSS code, such as variables, nesting, inheritance, mixins, functions, and mathematical operations. 
CSS preprocessors make it easy to automate repetitive tasks, 
reduce the number of errors and code bloat, create reusable code snippets, and ensure backward compatibility.

<b>Variables</b>
$primary-font-stack: 'Helvetica', sans-serif;
$primary-color: #fccd48;

body {
    color: $primary-color;
    font-family: $primary-font-stack;
}

<b>functions/mixins</b>
@mixin border-radius($radius) {
    -webkit-border-radius: $radius;
       -moz-border-radius: $radius;
        -ms-border-radius: $radius;
            border-radius: $radius;
}

.box {
    @include border-radius(10px);
}

</pre>




				<h3>Programmming paradigms</h3>
				<pre>
<b>Imperative: Object Oriented programming</b>

let arr = [1,2,3,4,5];
arr2 = [];
for(let i = 0;i&lt;arr.length;i++){
	arr[i] = arr[i]*2;
}
console.log(arr2);

<b>Declarative: functional programming</b>

let arr = [1,2,3,4,5];
arr2 = arr.map(function(v, i){
	return v*2;
});
console.log(arr2);
</pre>

				<h3>Design patterns javascript</h3>
				<pre>
1) <b>Module design pattern</b>:  Function variable with self invoking having all the methods encapsulated inside it
	create functions as module where we can 
2) <b>Prototype</b>
	TeslaModelS.prototype.go = function() {
		// Rotate wheels
	}
3) <b>Singleton</b>: A Singleton only allows for a single instantiation, but many instances of the same object. 
	The Singleton restricts clients from creating multiple objects, after the first object created, it will return instances of itself.
	var officePrinter = printer.getInstance();
4) <b>Observer</b>: There are many times when one part of the application changes, other parts needs to be updated.
var Subject = function() {
	this.observers = [];
	return {
		subscribeObserver: function(observer) {
			this.observers.push(observer);
		}
	};
};

var Observer = function() {
	return {
	notify: function(index) {
		console.log("Observer " + index + " is notified!");
	}
	}
}

var subject = new Subject();
var observer1 = new Observer();
subject.subscribeObserver(observer1);
</pre>

				<h3>Different ways to create an object:</h3>
				<pre>
1) <b>Object Literals</b>
var car = {
	model: 'bmw',
	color: 'red',
	price: 2000
}
	
2) <b>New operator or constructor</b>
function Car(model, color) {
	this.model = model;
	this.color = color;
}
var c1 = new Car('BMW', 'red');
	
3) <b>Object.create method</b>
var Car = {
	model: 'BMW',
	color: 'red'
}
var ElectricCar = Object.create(Car);
console.log(ElectricCar.model); // BMW
4) <b>Class</b>
class Car {
	constructor(maker, price) {
		this.maker = maker;
		this.price = price;
	}
	getInfo() {
		console.log(this.maker + " costs : " + this.price);
	}
}
</pre>

				<h3>Closures</h3>
				<pre>
A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). 
In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, 
closures are created every time a function is created, at function creation time.
</pre>

				<h3>Call, apply and bind</h3>
				<pre>
You can use call()/apply() to invoke the function immediately. 
bind() returns a bound function that, when executed later.

// <b>Call</b>
var obj = {name:"Goutam"};
var greeting = function(a,b,c){
	return "welcome "+this.name+" to "+a+" "+b+" in "+c;
};
console.log(greeting.call(obj,"Newtown","Bengaluru","Karnataka"));
// returns output as welcome Goutam to Newtown Bengaluru in Karnataka

// <b>Apply</b>
var obj = {name:"Goutam"};
var greeting = function(a,b,c){
    return "welcome "+this.name+" to "+a+" "+b+" in "+c;
};
var args = ["Newtown","Bengaluru","Karnataka"];  
console.log("Output using .apply() below ")
console.log(greeting.apply(obj,args));
// returns output as welcome Goutam to Newtown Bengaluru in Karnataka

// <b>Bind</b>
var obj = {name:"Niladri"};
var greeting = function(a,b,c){
    return "welcome "+this.name+" to "+a+" "+b+" in "+c;
};
//creates a bound function that has same body and parameters 
var bound = greeting.bind(obj); 
console.dir(bound); ///returns a function
console.log("Output using .bind() below ");
console.log(bound("Newtown","KOLKATA","WB")); //call the bound function
// returns output as welcome Goutam to Newtown Bengaluru in Karnataka

</pre>

				<h3>Observables and Promises</h3>
				<pre>
An Observable is like a Stream (in many languages) and allows to pass zero or more events where the callback is called for each event. 
Often Observable is preferred over Promise because it provides the features of Promise and more. 
With Observable it doesn't matter if you want to handle 0, 1, or multiple events.
Observable also has the advantage over Promise to be cancelable.
If the result of an HTTP request to a server or some other expensive async operation isn't needed anymore, 
the Subscription of an Observable allows to cancel the subscription, 
while a Promise will eventually call the success or failed callback even when you don't need the notification or the result it provides anymore.
Promise is always asynchronous, while an Observable can be either synchronous or asynchronous.
	
Promise
A Promise handles a single event when an async operation completes or fails. Promise is always asynchronous and non-cancelable.
Once the operation started whether it gives resolve/success or reject/failure
</pre>

				<h3>ES6 includes the following new features:</h3>
				<pre>
arrows function
classes
enhanced object literals
template strings
destructuring
default + rest + spread
let + const
iterators + for..of
promises
generators
unicode
modules
module loaders
map + set + weakmap + weakset
proxies
symbols
subclassable built-ins
math + number + string + array + object APIs
binary and octal literals
reflect api
tail calls
</pre>

				<h3>Rest and Spread operators</h3>
				<pre>
<b>Rest operator</b>: The ...rest must always be last.
function showName(firstName, lastName, ...titles) {
	alert( firstName + ' ' + lastName ); // Julius Caesar
	// the rest go into titles array
	// i.e. titles = ["Consul", "Imperator"]
	alert( titles[0] ); // Consul
	alert( titles[1] ); // Imperator
}
showName("Julius", "Caesar", "Consul", "Imperator");

<b>Spread operator</b> 
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [...arr, ...arr2];
console.log(merged); // 3,5,1,8,9,15
</pre>

				<h2>RXJS</h2>
				<div class="bgColor">
					<h3>Subject</h3>
					<div>
						A special type of Observable which shares a single execution path among observers

						<pre>
import { Subject } from 'rxjs';

const sub = new Subject();

sub.next(1);
sub.subscribe(x => {
console.log('Subscriber A', x);
});
sub.next(2); // OUTPUT => Subscriber A 2
sub.subscribe(x => {
console.log('Subscriber B', x);
});
sub.next(3); // OUTPUT => Subscriber A 3, Subscriber B 3 (logged from both subscribers)
</pre>
					</div>

					<h3>BehaviourSubject</h3>
					<div>
						The BehaviorSubject has the characteristic that it stores the “current” value. This means that
						you can
						always directly get the last emitted value from the BehaviorSubject.
						<pre>
import * as Rx from "rxjs";

const subject = new Rx.BehaviorSubject(Math.random());

// subscriber 1
subject.subscribe((data) => {
console.log('Subscriber A:', data);
});

// output
// Subscriber A: 0.24957144215097515
</pre>
					</div>

					<h3>ReplaySubject</h3>
					<div>
						The ReplaySubject is comparable to the BehaviorSubject in the way that it can send “old” values
						to new
						subscribers.
						It however has the extra characteristic that it can record a part of the observable execution
						and therefore
						store multiple old values and “replay” them to new subscribers.
						When creating the ReplaySubject you can specify how much values you want to store and for how
						long you want
						to store them.
					</div>
					<pre>
import * as Rx from "rxjs";

const subject = new Rx.ReplaySubject(2);

// subscriber 1
subject.subscribe((data) => {
console.log('Subscriber A:', data);
});

subject.next(Math.random())
subject.next(Math.random())
subject.next(Math.random())

// subscriber 2
subject.subscribe((data) => {
console.log('Subscriber B:', data);
});

subject.next(Math.random());

// Subscriber A: 0.3541746356538569
// Subscriber A: 0.12137498878080955
// Subscriber A: 0.531935186034298
// Subscriber B: 0.12137498878080955
// Subscriber B: 0.531935186034298
// Subscriber A: 0.6664809293975393
// Subscriber B: 0.6664809293975393
</pre>

					<h3>AsyncSubject</h3>
					<div>
						While the BehaviorSubject and ReplaySubject both store values, the AsyncSubject works a bit
						different.
						The AsyncSubject is aSubject variant where only the last value of the Observable execution is
						sent to its
						subscribers, and only when the execution completes.
					</div>
					<pre>
import * as Rx from "rxjs";

const subject = new Rx.AsyncSubject();

// subscriber 1
subject.subscribe((data) => {
console.log('Subscriber A:', data);
});

subject.next(Math.random())
subject.next(Math.random())
subject.next(Math.random())

// subscriber 2
subject.subscribe((data) => {
console.log('Subscriber B:', data);
});

subject.next(Math.random());
subject.complete();

// Subscriber A: 0.4447275989704571
// Subscriber B: 0.4447275989704571
</pre>
				</div>

				<h2>Fixing CORS Issues in Your Front-End Angular 7/8 App with Angular CLI Proxy Configuration</h2>
				<div>
					<a href="https://www.techiediaries.com/fix-cors-with-angular-cli-proxy-configuration/"
						rel="noreferrer noopener"></a>
				</div>
				<pre>
<b>Step 1 - Create a Proxy Configuration File(src/proxy.conf.json)</b>
{
    "/api/*": {
        "target": "http://localhost:3000",
        "secure": false,
        "logLevel": "debug"
    }
}
This configuration file specifies that any HTTP request which starts with the /app/ path will be sent to the proxy which will redirect it to the target hostname.
The secure option is used to enforce usage of SSL.

<b>Step 2 - Add a proxyConfig key to angular.json</b>
Next, open the angular.json file and add a proxyConfig key under the serve->options that points to the src/proxy.conf.json file as follows:
"architect": {
  "serve": {
    "builder": "@angular-devkit/build-angular:dev-server",
    "options": {
      "browserTarget": "your-application-name:build",
      "proxyConfig": "src/proxy.conf.json"
    },

<b>Step 3 - Serving your Angular App (ng serve)</b>
</pre>

				<h2>6 Ways to Unsubscribe from Observables in Angular</h2>
				<pre>
<b>Use the unsubscribe method</b>
@Component({...})
export class AppComponent implements OnInit, OnDestroy {
    subscription: Subscription 
    ngOnInit () {
        var observable = Rx.Observable.interval(1000);
        this.subscription = observable.subscribe(x => console.log(x));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe()
    }
}

<b>Use Async | Pipe</b>
@Component({
...,
template: `
<span>Interval: {{observable$ | async}}</span>
`
})
export class AppComponent implements OnInit {
	observable$
	ngOnInit () {
		this.observable$ = Rx.Observable.interval(1000);
	}
}

<b>Use RxJS take* operators</b>
take(n):
@Component({
    ...
})
export class AppComponent implements OnInit, OnDestroy {
    subscription$
    ngOnInit () {
        var observable$ = Rx.Observable.interval(1000);
        this.subscription$ = observable$.pipe(take(1)).
        subscribe(x => console.log(x))
    }
    ngOnDestroy() {
        this.subscription$.unsubscribe()
    }
}

takeUntil(notifier):
@Component({...})
export class AppComponent implements OnInit, OnDestroy {
    notifier = new Subject()
    ngOnInit () {
        var observable$ = Rx.Observable.interval(1000);
        observable$.pipe(takeUntil(this.notifier))
        .subscribe(x => console.log(x));
    }
    ngOnDestroy() {
        this.notifier.next()
        this.notifier.complete()
    }
}

takeWhile(predicate):
@Component({...})
export class AppComponent implements OnInit {
    ngOnInit () {
        var observable$ = Rx.Observable.interval(1000);
        observable$.pipe(takeWhile(value => value < 10))
        .subscribe(x => console.log(x));
    }
}

<b>Use RxJS first operator</b>
This operator is like the concatenation of take(1) and takeWhile.
If called with no value, it emits the first value emitted by the source Observable and completes.
@Component({...})
export class AppComponent implements OnInit {
    observable$
    ngOnInit () {
        this.observable = Rx.Observable.interval(1000);
        this.observable$.pipe(first())
        .subscribe(x => console.log(x));
    }
}

<b>Use Decorator to automate Unsubscription</b>
function AutoUnsub() {
    return function(constructor) {
        const orig = constructor.prototype.ngOnDestroy
        constructor.prototype.ngOnDestroy = function() {
            for(const prop in this) {
                const property = this[prop]
                if(typeof property.subscribe === "function") {
                    property.unsubscribe()
                }
            }
            orig.apply()
        }
    }
}

This AutoUnsub is a class decorator that can be applied to classes in our Angular project.
See, it saves the original ngOnDestroy hook, then creates a new one and hook it into the class it is applied on.
So, when the class is being destroyed the new hook is called.
Inside it, the functions scan through the properties of the class, if it finds an Observable property it will unsubscribe from it.
Then it calls the original ngOnDestroy hook in the class if present.

@Component({
    ...
})
@AutoUnsub
export class AppComponent implements OnInit {
    observable$
    ngOnInit () {
        this.observable$ = Rx.Observable.interval(1000);
        this.observable$.subscribe(x => console.log(x))
    }
}

</pre>

			</section>

			<aside id="sidebar">
				<a href="https://github.com/Gautampsingh/frontend_questions/zipball/master" class="button">
					<small>Download</small>
					.zip file
				</a>
				<a href="https://github.com/Gautampsingh/frontend_questions/tarball/master" class="button">
					<small>Download</small>
					.tar.gz file
				</a>

				<p class="repo-owner"><a href="https://github.com/Gautampsingh/frontend_questions"></a> is maintained by
					<a href="https://github.com/Gautampsingh">Gautampsingh</a>.</p>

				<p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect
					theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
			</aside>
		</div>
	</div>

</body>

</html>